"""
GitHub Issue Workflow Orchestrator

This file contains all workflow logic in one place for easy reading and modification.

WORKFLOW STATES:
  ANALYZING → RECOMMENDATION_PENDING → CREATING → BACKLOG → READY → IN_PROGRESS → IN_REVIEW

TRANSITIONS:
  1. User message → AI generates recommendation (ANALYZING → RECOMMENDATION_PENDING)
  2. User confirms → Create GitHub Issue (RECOMMENDATION_PENDING → CREATING)
  3. Issue created → Add to project with Backlog status (CREATING → BACKLOG)
  4. Auto-transition → Update to Ready status (BACKLOG → READY)
  5. Status detection → Move to In Progress, assign Copilot (READY → IN_PROGRESS)
  6. Completion detection → Move to In Review, assign owner (IN_PROGRESS → IN_REVIEW)
"""

import logging
from dataclasses import dataclass
from enum import Enum
from typing import TYPE_CHECKING

from src.models.chat import (
    IssueRecommendation,
    IssueMetadata,
    TriggeredBy,
    WorkflowConfiguration,
    WorkflowResult,
    WorkflowTransition,
)

if TYPE_CHECKING:
    from src.services.ai_agent import AIAgentService
    from src.services.github_projects import GitHubProjectsService

logger = logging.getLogger(__name__)


class WorkflowState(Enum):
    """Workflow states for tracking issue lifecycle."""

    ANALYZING = "analyzing"
    RECOMMENDATION_PENDING = "recommendation_pending"
    CREATING = "creating"
    BACKLOG = "backlog"
    READY = "ready"
    IN_PROGRESS = "in_progress"
    IN_REVIEW = "in_review"
    ERROR = "error"


@dataclass
class WorkflowContext:
    """Context passed through workflow transitions."""

    session_id: str
    project_id: str
    access_token: str
    repository_owner: str = ""
    repository_name: str = ""
    recommendation_id: str | None = None
    issue_id: str | None = None
    issue_number: int | None = None
    issue_url: str | None = None
    project_item_id: str | None = None
    current_state: WorkflowState = WorkflowState.ANALYZING
    config: WorkflowConfiguration | None = None


# In-memory storage for workflow transitions (audit log)
_transitions: list[WorkflowTransition] = []

# In-memory storage for workflow configurations (per project)
_workflow_configs: dict[str, WorkflowConfiguration] = {}


def get_workflow_config(project_id: str) -> WorkflowConfiguration | None:
    """Get workflow configuration for a project."""
    return _workflow_configs.get(project_id)


def set_workflow_config(project_id: str, config: WorkflowConfiguration) -> None:
    """Set workflow configuration for a project."""
    _workflow_configs[project_id] = config


def get_transitions(issue_id: str | None = None, limit: int = 50) -> list[WorkflowTransition]:
    """Get workflow transitions, optionally filtered by issue_id."""
    if issue_id:
        filtered = [t for t in _transitions if t.issue_id == issue_id]
        return filtered[-limit:]
    return _transitions[-limit:]


class WorkflowOrchestrator:
    """Orchestrates the full GitHub issue creation and status workflow."""

    def __init__(
        self,
        ai_service: "AIAgentService",
        github_service: "GitHubProjectsService",
    ):
        self.ai = ai_service
        self.github = github_service

    # ──────────────────────────────────────────────────────────────────
    # HELPER: Format Issue Body
    # ──────────────────────────────────────────────────────────────────
    def format_issue_body(self, recommendation: IssueRecommendation) -> str:
        """
        Format recommendation into markdown body for GitHub Issue.

        Args:
            recommendation: The AI-generated recommendation

        Returns:
            Formatted markdown string
        """
        requirements_list = "\n".join(
            f"- {req}" for req in recommendation.functional_requirements
        )

        # Format metadata section
        metadata = recommendation.metadata if hasattr(recommendation, 'metadata') and recommendation.metadata else None
        metadata_section = ""
        if metadata:
            metadata_section = f"""## Metadata

| Field | Value |
|-------|-------|
| Priority | {metadata.priority.value if metadata.priority else 'P2'} |
| Size | {metadata.size.value if metadata.size else 'M'} |
| Estimate | {metadata.estimate_hours}h |
| Start Date | {metadata.start_date or 'TBD'} |
| Target Date | {metadata.target_date or 'TBD'} |

"""

        body = f"""## User Story

{recommendation.user_story}

## UI/UX Description

{recommendation.ui_ux_description}

## Functional Requirements

{requirements_list}

{metadata_section}---
*Generated by AI from feature request*
"""
        return body

    # ──────────────────────────────────────────────────────────────────
    # HELPER: Log Transition
    # ──────────────────────────────────────────────────────────────────
    def log_transition(
        self,
        ctx: WorkflowContext,
        from_status: str | None,
        to_status: str,
        triggered_by: TriggeredBy,
        success: bool,
        error_message: str | None = None,
        assigned_user: str | None = None,
    ) -> WorkflowTransition:
        """
        Log a workflow transition for audit purposes.

        Args:
            ctx: Current workflow context
            from_status: Previous status
            to_status: New status
            triggered_by: What triggered the transition
            success: Whether it succeeded
            error_message: Error details if failed
            assigned_user: User assigned during transition

        Returns:
            The created transition record
        """
        transition = WorkflowTransition(
            issue_id=ctx.issue_id or "",
            project_id=ctx.project_id,
            from_status=from_status,
            to_status=to_status,
            assigned_user=assigned_user,
            triggered_by=triggered_by,
            success=success,
            error_message=error_message,
        )
        _transitions.append(transition)
        logger.info(
            "Transition logged: %s → %s (success=%s)",
            from_status or "None",
            to_status,
            success,
        )
        return transition

    # ──────────────────────────────────────────────────────────────────
    # STEP 1: Create GitHub Issue (T022)
    # ──────────────────────────────────────────────────────────────────
    async def create_issue_from_recommendation(
        self, ctx: WorkflowContext, recommendation: IssueRecommendation
    ) -> dict:
        """
        Create GitHub Issue from confirmed recommendation.

        Args:
            ctx: Workflow context with auth and project info
            recommendation: The confirmed recommendation

        Returns:
            Dict with issue details (id, node_id, number, html_url)

        Raises:
            Exception: If issue creation fails
        """
        logger.info("Creating GitHub issue: %s", recommendation.title)
        ctx.current_state = WorkflowState.CREATING

        body = self.format_issue_body(recommendation)

        issue = await self.github.create_issue(
            access_token=ctx.access_token,
            owner=ctx.repository_owner,
            repo=ctx.repository_name,
            title=recommendation.title,
            body=body,
            labels=["ai-generated"],
        )

        ctx.issue_id = issue["node_id"]
        ctx.issue_number = issue["number"]
        ctx.issue_url = issue["html_url"]

        logger.info("Created issue #%d: %s", issue["number"], issue["html_url"])
        return issue

    # ──────────────────────────────────────────────────────────────────
    # STEP 2: Add to Project with Backlog Status (T023)
    # ──────────────────────────────────────────────────────────────────
    async def add_to_project_with_backlog(
        self, ctx: WorkflowContext, recommendation: IssueRecommendation | None = None
    ) -> str:
        """
        Add created issue to GitHub Project with Backlog status.

        Args:
            ctx: Workflow context with issue_id populated
            recommendation: Optional recommendation with metadata to set

        Returns:
            Project item ID

        Raises:
            Exception: If project attachment fails
        """
        if not ctx.issue_id:
            raise ValueError("No issue_id in context - create issue first")

        logger.info("Adding issue %s to project %s", ctx.issue_id, ctx.project_id)

        # Add issue to project
        item_id = await self.github.add_issue_to_project(
            access_token=ctx.access_token,
            project_id=ctx.project_id,
            issue_node_id=ctx.issue_id,
        )

        ctx.project_item_id = item_id
        ctx.current_state = WorkflowState.BACKLOG

        # Set metadata fields if recommendation has metadata
        if recommendation and hasattr(recommendation, 'metadata') and recommendation.metadata:
            await self._set_issue_metadata(ctx, recommendation.metadata)

        # Log the transition
        self.log_transition(
            ctx=ctx,
            from_status=None,
            to_status="Backlog",
            triggered_by=TriggeredBy.AUTOMATIC,
            success=True,
        )

        logger.info("Added to project, item_id: %s", item_id)
        return item_id

    async def _set_issue_metadata(
        self, ctx: WorkflowContext, metadata: "IssueMetadata"
    ) -> None:
        """
        Set metadata fields on a project item.

        Args:
            ctx: Workflow context with project_item_id populated
            metadata: IssueMetadata with priority, size, dates, etc.
        """
        if not ctx.project_item_id:
            logger.warning("No project_item_id - cannot set metadata")
            return

        try:
            # Convert metadata to dict for the service
            metadata_dict = {
                "priority": metadata.priority.value if metadata.priority else None,
                "size": metadata.size.value if metadata.size else None,
                "estimate_hours": metadata.estimate_hours,
                "start_date": metadata.start_date,
                "target_date": metadata.target_date,
            }

            results = await self.github.set_issue_metadata(
                access_token=ctx.access_token,
                project_id=ctx.project_id,
                item_id=ctx.project_item_id,
                metadata=metadata_dict,
            )

            logger.info("Metadata set results: %s", results)

        except Exception as e:
            # Log but don't fail the workflow - metadata is nice-to-have
            logger.warning("Failed to set issue metadata: %s", e)

    # ──────────────────────────────────────────────────────────────────
    # STEP 3: Transition to Ready (T031)
    # ──────────────────────────────────────────────────────────────────
    async def transition_to_ready(self, ctx: WorkflowContext) -> bool:
        """
        Automatically transition issue from Backlog to Ready.

        Args:
            ctx: Workflow context with project_item_id populated

        Returns:
            True if transition succeeded
        """
        if not ctx.project_item_id:
            raise ValueError("No project_item_id in context - add to project first")

        config = ctx.config or get_workflow_config(ctx.project_id)
        if not config:
            logger.warning("No workflow config for project %s", ctx.project_id)
            return False

        logger.info("Transitioning issue %s to Ready", ctx.issue_id)

        # Get status field info from project
        # This will be implemented in github_projects.py
        success = await self.github.update_item_status_by_name(
            access_token=ctx.access_token,
            project_id=ctx.project_id,
            item_id=ctx.project_item_id,
            status_name=config.status_ready,
        )

        if success:
            ctx.current_state = WorkflowState.READY
            self.log_transition(
                ctx=ctx,
                from_status=config.status_backlog,
                to_status=config.status_ready,
                triggered_by=TriggeredBy.AUTOMATIC,
                success=True,
            )
        else:
            self.log_transition(
                ctx=ctx,
                from_status=config.status_backlog,
                to_status=config.status_ready,
                triggered_by=TriggeredBy.AUTOMATIC,
                success=False,
                error_message="Failed to update status",
            )

        return success

    # ──────────────────────────────────────────────────────────────────
    # STEP 4: Handle Ready Status (T038, T042)
    # ──────────────────────────────────────────────────────────────────
    async def handle_ready_status(self, ctx: WorkflowContext) -> bool:
        """
        When Ready status detected: assign GitHub Copilot (with optional custom agent)
        and transition to In Progress.

        If a custom_agent is configured (e.g., 'speckit.specify'), the issue title,
        description, and all comments/discussions are fetched and passed as the
        prompt/custom instructions to the agent.

        Args:
            ctx: Workflow context

        Returns:
            True if transition succeeded (assignment failures are logged but don't fail the transition)
        """
        config = ctx.config or get_workflow_config(ctx.project_id)
        if not config:
            logger.warning("No workflow config for project %s", ctx.project_id)
            return False

        logger.info("Issue %s is Ready, assigning Copilot and transitioning to In Progress", ctx.issue_id)

        # Prepare custom agent configuration
        custom_agent = config.custom_agent if hasattr(config, 'custom_agent') else ""
        custom_instructions = ""

        # If a custom agent is configured, fetch issue details for the prompt
        if custom_agent and ctx.issue_number:
            logger.info("Fetching issue details for custom agent '%s'", custom_agent)
            issue_data = await self.github.get_issue_with_comments(
                access_token=ctx.access_token,
                owner=ctx.repository_owner,
                repo=ctx.repository_name,
                issue_number=ctx.issue_number,
            )
            custom_instructions = self.github.format_issue_context_as_prompt(issue_data)
            logger.info(
                "Prepared custom instructions for agent '%s' (length: %d chars)",
                custom_agent,
                len(custom_instructions),
            )

        # Try to assign GitHub Copilot Agent (with custom agent if configured)
        copilot_assigned = await self.github.assign_copilot_to_issue(
            access_token=ctx.access_token,
            owner=ctx.repository_owner,
            repo=ctx.repository_name,
            issue_node_id=ctx.issue_id,
            issue_number=ctx.issue_number,
            custom_agent=custom_agent,
            custom_instructions=custom_instructions,
        )

        if copilot_assigned:
            if custom_agent:
                logger.info(
                    "Successfully assigned GitHub Copilot with custom agent '%s' to issue #%d",
                    custom_agent,
                    ctx.issue_number,
                )
            else:
                logger.info("Successfully assigned GitHub Copilot to issue #%d", ctx.issue_number)
        else:
            logger.warning("Could not assign GitHub Copilot to issue #%d - Copilot may not be available", ctx.issue_number)
            
            # Fall back to configured assignee if Copilot assignment failed
            assignee = config.copilot_assignee
            if assignee:
                assignee_valid = await self.github.validate_assignee(
                    access_token=ctx.access_token,
                    owner=ctx.repository_owner,
                    repo=ctx.repository_name,
                    username=assignee,
                )

                if assignee_valid:
                    assign_success = await self.github.assign_issue(
                        access_token=ctx.access_token,
                        owner=ctx.repository_owner,
                        repo=ctx.repository_name,
                        issue_number=ctx.issue_number,
                        assignees=[assignee],
                    )
                    if assign_success:
                        logger.info("Fallback: Assigned %s to issue #%d", assignee, ctx.issue_number)
                    else:
                        logger.warning("Fallback: Failed to assign %s to issue #%d", assignee, ctx.issue_number)

        # Update status to In Progress
        status_success = await self.github.update_item_status_by_name(
            access_token=ctx.access_token,
            project_id=ctx.project_id,
            item_id=ctx.project_item_id,
            status_name=config.status_in_progress,
        )

        if not status_success:
            self.log_transition(
                ctx=ctx,
                from_status=config.status_ready,
                to_status=config.status_in_progress,
                triggered_by=TriggeredBy.AUTOMATIC,
                success=False,
                error_message="Failed to update status to In Progress",
            )
            return False

        ctx.current_state = WorkflowState.IN_PROGRESS
        
        # Log which agent was used
        assigned_agent = custom_agent if custom_agent and copilot_assigned else None
        self.log_transition(
            ctx=ctx,
            from_status=config.status_ready,
            to_status=config.status_in_progress,
            triggered_by=TriggeredBy.AUTOMATIC,
            success=True,
            assigned_user=f"copilot:{custom_agent}" if assigned_agent else ("copilot" if copilot_assigned else config.copilot_assignee),
        )

        return True

    # ──────────────────────────────────────────────────────────────────
    # STEP 5: Handle In Progress Status - Check for PR Completion
    # ──────────────────────────────────────────────────────────────────
    async def handle_in_progress_status(self, ctx: WorkflowContext) -> bool:
        """
        When issue is In Progress: check if Copilot has completed the PR.

        If Copilot has finished (PR is no longer draft), this will:
        1. Update issue status to In Review
        2. Mark the draft PR as ready for review (if still draft)
        3. Assign reviewer to the issue

        Args:
            ctx: Workflow context

        Returns:
            True if PR completion detected and handled, False if still in progress
        """
        config = ctx.config or get_workflow_config(ctx.project_id)
        if not config:
            logger.warning("No workflow config for project %s", ctx.project_id)
            return False

        logger.info("Checking if Copilot has completed PR for issue #%d", ctx.issue_number)

        # Check for completed Copilot PR
        completed_pr = await self.github.check_copilot_pr_completion(
            access_token=ctx.access_token,
            owner=ctx.repository_owner,
            repo=ctx.repository_name,
            issue_number=ctx.issue_number,
        )

        if not completed_pr:
            logger.info("No completed Copilot PR found for issue #%d - still in progress", ctx.issue_number)
            return False

        logger.info(
            "Copilot PR #%d is complete for issue #%d, transitioning to In Review",
            completed_pr["number"],
            ctx.issue_number,
        )

        # If PR is still marked as draft, mark it ready for review
        if completed_pr.get("is_draft"):
            pr_node_id = completed_pr.get("id")
            if pr_node_id:
                mark_success = await self.github.mark_pr_ready_for_review(
                    access_token=ctx.access_token,
                    pr_node_id=pr_node_id,
                )
                if mark_success:
                    logger.info("Marked PR #%d as ready for review", completed_pr["number"])
                else:
                    logger.warning("Failed to mark PR #%d as ready for review", completed_pr["number"])

        # Update status to In Review
        status_success = await self.github.update_item_status_by_name(
            access_token=ctx.access_token,
            project_id=ctx.project_id,
            item_id=ctx.project_item_id,
            status_name=config.status_in_review,
        )

        if not status_success:
            self.log_transition(
                ctx=ctx,
                from_status=config.status_in_progress,
                to_status=config.status_in_review,
                triggered_by=TriggeredBy.DETECTION,
                success=False,
                error_message="Failed to update status to In Review",
            )
            return False

        # Determine reviewer (use configured or fall back to repo owner)
        reviewer = config.review_assignee
        if not reviewer:
            reviewer = await self.github.get_repository_owner(
                access_token=ctx.access_token,
                owner=ctx.repository_owner,
                repo=ctx.repository_name,
            )

        # Assign reviewer
        assign_success = await self.github.assign_issue(
            access_token=ctx.access_token,
            owner=ctx.repository_owner,
            repo=ctx.repository_name,
            issue_number=ctx.issue_number,
            assignees=[reviewer] if reviewer else [],
        )

        ctx.current_state = WorkflowState.IN_REVIEW
        self.log_transition(
            ctx=ctx,
            from_status=config.status_in_progress,
            to_status=config.status_in_review,
            triggered_by=TriggeredBy.DETECTION,
            success=True,
            assigned_user=reviewer if assign_success else None,
        )

        if assign_success:
            logger.info(
                "Issue #%d transitioned to In Review, assigned to %s, PR #%d ready",
                ctx.issue_number,
                reviewer,
                completed_pr["number"],
            )
        else:
            logger.warning(
                "Issue #%d transitioned to In Review but failed to assign %s",
                ctx.issue_number,
                reviewer,
            )

        return True

    # ──────────────────────────────────────────────────────────────────
    # STEP 6: Detect Completion Signal (T044)
    # ──────────────────────────────────────────────────────────────────
    def detect_completion_signal(self, task: dict) -> bool:
        """
        Check if a task has completion indicators.

        Completion is signaled when:
        - Issue is closed, OR
        - Issue has 'copilot-complete' label

        Args:
            task: Task/issue data from GitHub

        Returns:
            True if completion signal detected
        """
        # Check for closed status
        if task.get("state") == "closed":
            return True

        # Check for completion label
        labels = task.get("labels", [])
        label_names = [lbl.get("name", "") for lbl in labels]
        if "copilot-complete" in label_names:
            return True

        return False

    # ──────────────────────────────────────────────────────────────────
    # STEP 6: Handle Completion (T045)
    # ──────────────────────────────────────────────────────────────────
    async def handle_completion(self, ctx: WorkflowContext) -> bool:
        """
        When completion detected: transition to In Review and assign owner.

        Args:
            ctx: Workflow context

        Returns:
            True if transition and assignment succeeded
        """
        config = ctx.config or get_workflow_config(ctx.project_id)
        if not config:
            logger.warning("No workflow config for project %s", ctx.project_id)
            return False

        logger.info("Issue %s complete, transitioning to In Review", ctx.issue_id)

        # Update status to In Review
        status_success = await self.github.update_item_status_by_name(
            access_token=ctx.access_token,
            project_id=ctx.project_id,
            item_id=ctx.project_item_id,
            status_name=config.status_in_review,
        )

        if not status_success:
            self.log_transition(
                ctx=ctx,
                from_status=config.status_in_progress,
                to_status=config.status_in_review,
                triggered_by=TriggeredBy.DETECTION,
                success=False,
                error_message="Failed to update status to In Review",
            )
            return False

        # Determine reviewer (use configured or fall back to repo owner)
        reviewer = config.review_assignee
        if not reviewer:
            reviewer = await self.github.get_repository_owner(
                access_token=ctx.access_token,
                owner=ctx.repository_owner,
                repo=ctx.repository_name,
            )

        # Assign reviewer
        assign_success = await self.github.assign_issue(
            access_token=ctx.access_token,
            owner=ctx.repository_owner,
            repo=ctx.repository_name,
            issue_number=ctx.issue_number,
            assignees=[reviewer] if reviewer else [],
        )

        ctx.current_state = WorkflowState.IN_REVIEW
        self.log_transition(
            ctx=ctx,
            from_status=config.status_in_progress,
            to_status=config.status_in_review,
            triggered_by=TriggeredBy.DETECTION,
            success=True,
            assigned_user=reviewer if assign_success else None,
        )

        if not assign_success:
            logger.warning(
                "Failed to assign reviewer %s to issue #%d",
                reviewer,
                ctx.issue_number,
            )

        return True

    # ──────────────────────────────────────────────────────────────────
    # FULL WORKFLOW: Execute from confirmation to Ready (T022+T023+T031)
    # ──────────────────────────────────────────────────────────────────
    async def execute_full_workflow(
        self, ctx: WorkflowContext, recommendation: IssueRecommendation
    ) -> WorkflowResult:
        """
        Execute the complete workflow from confirmation to Ready status.

        This orchestrates:
        1. Create GitHub Issue from recommendation
        2. Add issue to project with Backlog status
        3. Transition to Ready status

        Args:
            ctx: Workflow context
            recommendation: The confirmed recommendation

        Returns:
            WorkflowResult with success status and details
        """
        try:
            # Step 1: Create issue
            issue = await self.create_issue_from_recommendation(ctx, recommendation)

            # Step 2: Add to project with metadata
            await self.add_to_project_with_backlog(ctx, recommendation)

            # Step 3: Transition to Ready
            await self.transition_to_ready(ctx)

            # Step 4: Assign GitHub Copilot and transition to In Progress
            await self.handle_ready_status(ctx)

            return WorkflowResult(
                success=True,
                issue_id=ctx.issue_id,
                issue_number=ctx.issue_number,
                issue_url=ctx.issue_url,
                project_item_id=ctx.project_item_id,
                current_status=ctx.current_state.value if ctx.current_state else "In Progress",
                message=f"Issue #{ctx.issue_number} created, added to project, and assigned to {ctx.config.copilot_assignee if ctx.config else 'Copilot'}",
            )

        except Exception as e:
            logger.error("Workflow failed: %s", e)
            ctx.current_state = WorkflowState.ERROR

            self.log_transition(
                ctx=ctx,
                from_status=ctx.current_state.value if ctx.current_state else None,
                to_status="error",
                triggered_by=TriggeredBy.AUTOMATIC,
                success=False,
                error_message=str(e),
            )

            return WorkflowResult(
                success=False,
                issue_id=ctx.issue_id,
                issue_number=ctx.issue_number,
                issue_url=ctx.issue_url,
                project_item_id=ctx.project_item_id,
                current_status="error",
                message=f"Workflow failed: {e}",
            )


# Global orchestrator instance (lazy initialization)
_orchestrator_instance: WorkflowOrchestrator | None = None


def get_workflow_orchestrator() -> WorkflowOrchestrator:
    """Get or create the global workflow orchestrator instance."""
    global _orchestrator_instance
    if _orchestrator_instance is None:
        from src.services.ai_agent import get_ai_agent_service
        from src.services.github_projects import github_projects_service

        _orchestrator_instance = WorkflowOrchestrator(
            ai_service=get_ai_agent_service(),
            github_service=github_projects_service,
        )
    return _orchestrator_instance
